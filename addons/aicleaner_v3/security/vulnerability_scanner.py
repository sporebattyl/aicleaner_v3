"""
Phase 3C: Vulnerability Scanner
Comprehensive vulnerability scanning for dependencies, configuration, and system security.
"""

import asyncio
import json
import logging
import os
import re
import subprocess
import sys
from typing import Dict, List, Any, Optional
from datetime import datetime
import pkg_resources
import stat


class VulnerabilityScanner:
    """
    Comprehensive vulnerability scanner for AICleaner v3.
    
    Scans for vulnerabilities in dependencies, configuration,
    file permissions, and system security.
    """
    
    def __init__(self, config: Dict[str, Any]):
        """
        Initialize vulnerability scanner.
        
        Args:
            config: Configuration dictionary
        """
        self.config = config
        self.logger = logging.getLogger(__name__)
        
        # Vulnerability databases (simplified for demo)
        self.known_vulns = {
            'requests': {
                '2.25.1': {
                    'cve': 'CVE-2023-32681',
                    'severity': 'medium',
                    'description': 'Unintended leak of Proxy-Authorization header to destination server'
                }
            },
            'urllib3': {
                '1.26.5': {
                    'cve': 'CVE-2023-43804',
                    'severity': 'high',
                    'description': 'Cookie request header isn\'t stripped during cross-origin redirects'
                }
            },
            'pillow': {
                '8.3.2': {
                    'cve': 'CVE-2023-44271',
                    'severity': 'critical',
                    'description': 'Uncontrolled resource consumption when textlength in an ImageDraw instance'
                }
            }
        }
        
        # Configuration security patterns
        self.insecure_config_patterns = [
            {
                'pattern': r'password\s*=\s*["\'].*["\']',
                'severity': 'high',
                'description': 'Hardcoded password in configuration',
                'recommendation': 'Use environment variables or secrets management'
            },
            {
                'pattern': r'api_key\s*=\s*["\'][^"\']{10,}["\']',
                'severity': 'critical',
                'description': 'Hardcoded API key in configuration',
                'recommendation': 'Move API keys to secure secrets storage'
            },
            {
                'pattern': r'secret\s*=\s*["\'].*["\']',
                'severity': 'high',
                'description': 'Hardcoded secret in configuration',
                'recommendation': 'Use secure secrets management'
            },
            {
                'pattern': r'token\s*=\s*["\'].*["\']',
                'severity': 'medium',
                'description': 'Hardcoded token in configuration',
                'recommendation': 'Store tokens securely'
            },
            {
                'pattern': r'debug\s*=\s*true',
                'severity': 'low',
                'description': 'Debug mode enabled in production',
                'recommendation': 'Disable debug mode for production'
            },
            {
                'pattern': r'ssl_verify\s*=\s*false',
                'severity': 'medium',
                'description': 'SSL verification disabled',
                'recommendation': 'Enable SSL verification'
            }
        ]
        
        self.logger.info("Vulnerability Scanner initialized")
    
    async def scan_dependencies(self) -> List[Dict[str, Any]]:
        """
        Scan installed Python packages for known vulnerabilities.
        
        Returns:
            List of vulnerability findings
        """
        vulnerabilities = []
        
        try:
            self.logger.info("Scanning Python dependencies for vulnerabilities...")
            
            # Get installed packages
            installed_packages = {pkg.project_name.lower(): pkg.version 
                                for pkg in pkg_resources.working_set}
            
            # Check against known vulnerabilities
            for package_name, version in installed_packages.items():
                if package_name in self.known_vulns:
                    vuln_versions = self.known_vulns[package_name]
                    
                    for vuln_version, vuln_info in vuln_versions.items():
                        if self._is_vulnerable_version(version, vuln_version):
                            vulnerability = {
                                'id': f"dep_{package_name}_{vuln_info.get('cve', 'unknown')}",
                                'package': package_name,
                                'installed_version': version,
                                'vulnerable_version': vuln_version,
                                'severity': vuln_info.get('severity', 'medium'),
                                'description': vuln_info.get('description', 'Known vulnerability'),
                                'cve_references': [vuln_info.get('cve')] if vuln_info.get('cve') else [],
                                'recommendations': [
                                    f"Update {package_name} to a version newer than {vuln_version}",
                                    "Run 'pip install --upgrade {package_name}'"
                                ],
                                'remediation_effort': 'low'
                            }
                            vulnerabilities.append(vulnerability)
            
            # Check for outdated packages (simplified check)
            outdated_packages = await self._check_outdated_packages()
            for package_info in outdated_packages:
                if package_info['severity'] in ['high', 'critical']:
                    vulnerability = {
                        'id': f"outdated_{package_info['package']}",
                        'package': package_info['package'],
                        'installed_version': package_info['current_version'],
                        'latest_version': package_info['latest_version'],
                        'severity': 'low',
                        'description': f"Package {package_info['package']} is outdated",
                        'cve_references': [],
                        'recommendations': [
                            f"Update {package_info['package']} to latest version",
                            f"pip install --upgrade {package_info['package']}"
                        ],
                        'remediation_effort': 'low'
                    }
                    vulnerabilities.append(vulnerability)
            
            self.logger.info(f"Found {len(vulnerabilities)} dependency vulnerabilities")
            return vulnerabilities
        
        except Exception as e:
            self.logger.error(f"Error scanning dependencies: {e}")
            return []
    
    def _is_vulnerable_version(self, installed: str, vulnerable: str) -> bool:
        """Check if installed version is vulnerable."""
        try:
            # Simple version comparison (in production, use proper version parsing)
            installed_parts = [int(x) for x in installed.split('.')]
            vulnerable_parts = [int(x) for x in vulnerable.split('.')]
            
            # Pad shorter version with zeros
            max_len = max(len(installed_parts), len(vulnerable_parts))
            installed_parts.extend([0] * (max_len - len(installed_parts)))
            vulnerable_parts.extend([0] * (max_len - len(vulnerable_parts)))
            
            return installed_parts <= vulnerable_parts
        except:
            return False
    
    async def _check_outdated_packages(self) -> List[Dict[str, Any]]:
        """Check for outdated packages (simplified implementation)."""
        try:
            # In a real implementation, this would check against PyPI
            # For demo, return some mock data
            return [
                {
                    'package': 'requests',
                    'current_version': '2.25.1',
                    'latest_version': '2.31.0',
                    'severity': 'medium'
                }
            ]
        except Exception as e:
            self.logger.error(f"Error checking outdated packages: {e}")
            return []
    
    async def scan_configuration(self) -> List[Dict[str, Any]]:
        """
        Scan configuration files for security issues.
        
        Returns:
            List of configuration vulnerabilities
        """
        vulnerabilities = []
        
        try:
            self.logger.info("Scanning configuration for security issues...")
            
            # Configuration files to scan
            config_files = [
                'config.yaml',
                'config.json',
                '.env',
                'docker-compose.yml',
                'requirements.txt'
            ]
            
            for config_file in config_files:
                file_path = os.path.join('/config', config_file)
                if os.path.exists(file_path):
                    vulns = await self._scan_config_file(file_path)
                    vulnerabilities.extend(vulns)
            
            # Scan addon configuration
            addon_config_path = '/data/options.json'
            if os.path.exists(addon_config_path):
                vulns = await self._scan_config_file(addon_config_path)
                vulnerabilities.extend(vulns)
            
            self.logger.info(f"Found {len(vulnerabilities)} configuration vulnerabilities")
            return vulnerabilities
        
        except Exception as e:
            self.logger.error(f"Error scanning configuration: {e}")
            return []
    
    async def _scan_config_file(self, file_path: str) -> List[Dict[str, Any]]:
        """Scan individual configuration file."""
        vulnerabilities = []
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Check for insecure patterns
            for i, line in enumerate(content.split('\n'), 1):
                for pattern_info in self.insecure_config_patterns:
                    if re.search(pattern_info['pattern'], line, re.IGNORECASE):
                        vulnerability = {
                            'title': pattern_info['description'],
                            'description': f"Line {i} in {file_path}: {pattern_info['description']}",
                            'severity': pattern_info['severity'],
                            'component': file_path,
                            'line_number': i,
                            'line_content': line.strip(),
                            'pattern': pattern_info['pattern'],
                            'recommendations': [pattern_info['recommendation']],
                            'remediation_effort': 'medium'
                        }
                        vulnerabilities.append(vulnerability)
            
            # Check file permissions
            file_stat = os.stat(file_path)
            file_mode = stat.filemode(file_stat.st_mode)
            
            # Check if config files are world-readable
            if file_stat.st_mode & stat.S_IROTH:
                vulnerability = {
                    'title': 'World-readable configuration file',
                    'description': f"Configuration file {file_path} is readable by all users",
                    'severity': 'medium',
                    'component': file_path,
                    'file_permissions': file_mode,
                    'recommendations': [
                        f"Change file permissions: chmod 600 {file_path}",
                        "Restrict access to configuration files"
                    ],
                    'remediation_effort': 'low'
                }
                vulnerabilities.append(vulnerability)
        
        except Exception as e:
            self.logger.error(f"Error scanning config file {file_path}: {e}")
        
        return vulnerabilities
    
    async def scan_file_permissions(self) -> List[Dict[str, Any]]:
        """
        Scan file system permissions for security issues.
        
        Returns:
            List of permission-related vulnerabilities
        """
        vulnerabilities = []
        
        try:
            self.logger.info("Scanning file permissions...")
            
            # Critical files/directories to check
            critical_paths = [
                '/data',
                '/config',
                '/ssl',
                '/share',
                '/backup'
            ]
            
            for path in critical_paths:
                if os.path.exists(path):
                    vulns = await self._check_path_permissions(path)
                    vulnerabilities.extend(vulns)
            
            # Check executable permissions on scripts
            script_paths = [
                '/data',
                '/config'
            ]
            
            for base_path in script_paths:
                if os.path.exists(base_path):
                    for root, dirs, files in os.walk(base_path):
                        for file in files:
                            if file.endswith(('.sh', '.py', '.pl')):
                                file_path = os.path.join(root, file)
                                vulns = await self._check_script_permissions(file_path)
                                vulnerabilities.extend(vulns)
            
            self.logger.info(f"Found {len(vulnerabilities)} permission issues")
            return vulnerabilities
        
        except Exception as e:
            self.logger.error(f"Error scanning file permissions: {e}")
            return []
    
    async def _check_path_permissions(self, path: str) -> List[Dict[str, Any]]:
        """Check permissions for a specific path."""
        vulnerabilities = []
        
        try:
            file_stat = os.stat(path)
            file_mode = stat.filemode(file_stat.st_mode)
            
            # Check if directory is world-writable
            if os.path.isdir(path) and (file_stat.st_mode & stat.S_IWOTH):
                vulnerability = {
                    'file': path,
                    'description': f"Directory {path} is world-writable",
                    'severity': 'high',
                    'file_permissions': file_mode,
                    'recommendations': [
                        f"Remove world-write permission: chmod o-w {path}",
                        "Restrict directory access to necessary users only"
                    ]
                }
                vulnerabilities.append(vulnerability)
            
            # Check if sensitive files are world-readable
            sensitive_patterns = ['key', 'secret', 'password', 'token', 'cert']
            if any(pattern in os.path.basename(path).lower() for pattern in sensitive_patterns):
                if file_stat.st_mode & stat.S_IROTH:
                    vulnerability = {
                        'file': path,
                        'description': f"Sensitive file {path} is world-readable",
                        'severity': 'medium',
                        'file_permissions': file_mode,
                        'recommendations': [
                            f"Restrict file access: chmod 600 {path}",
                            "Ensure sensitive files are not accessible to unauthorized users"
                        ]
                    }
                    vulnerabilities.append(vulnerability)
        
        except Exception as e:
            self.logger.error(f"Error checking permissions for {path}: {e}")
        
        return vulnerabilities
    
    async def _check_script_permissions(self, script_path: str) -> List[Dict[str, Any]]:
        """Check permissions for script files."""
        vulnerabilities = []
        
        try:
            file_stat = os.stat(script_path)
            file_mode = stat.filemode(file_stat.st_mode)
            
            # Check if script is world-writable
            if file_stat.st_mode & stat.S_IWOTH:
                vulnerability = {
                    'file': script_path,
                    'description': f"Script {script_path} is world-writable",
                    'severity': 'high',
                    'file_permissions': file_mode,
                    'recommendations': [
                        f"Remove world-write permission: chmod o-w {script_path}",
                        "Ensure scripts cannot be modified by unauthorized users"
                    ]
                }
                vulnerabilities.append(vulnerability)
            
            # Check if script is executable by others but contains sensitive operations
            if (file_stat.st_mode & stat.S_IXOTH) and os.path.isfile(script_path):
                # Read script content to check for sensitive operations
                try:
                    with open(script_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                    
                    sensitive_commands = ['rm -rf', 'dd if=', 'mkfs', 'fdisk', 'passwd', 'sudo']
                    if any(cmd in content for cmd in sensitive_commands):
                        vulnerability = {
                            'file': script_path,
                            'description': f"Script with sensitive commands {script_path} is executable by others",
                            'severity': 'medium',
                            'file_permissions': file_mode,
                            'recommendations': [
                                f"Restrict execution: chmod o-x {script_path}",
                                "Review script content and restrict access appropriately"
                            ]
                        }
                        vulnerabilities.append(vulnerability)
                
                except Exception:
                    pass  # Ignore read errors
        
        except Exception as e:
            self.logger.error(f"Error checking script permissions for {script_path}: {e}")
        
        return vulnerabilities
    
    async def scan_network_security(self) -> List[Dict[str, Any]]:
        """
        Scan network security configuration.
        
        Returns:
            List of network security issues
        """
        vulnerabilities = []
        
        try:
            self.logger.info("Scanning network security...")
            
            # Check for open ports (simplified check)
            open_ports = await self._check_open_ports()
            for port_info in open_ports:
                if port_info['risk_level'] in ['high', 'critical']:
                    vulnerability = {
                        'title': f"High-risk port {port_info['port']} open",
                        'description': f"Port {port_info['port']} ({port_info['service']}) is open and may pose security risk",
                        'severity': port_info['risk_level'],
                        'component': 'network',
                        'port': port_info['port'],
                        'service': port_info['service'],
                        'recommendations': [
                            f"Review if port {port_info['port']} needs to be open",
                            "Configure firewall rules to restrict access",
                            "Use VPN or secure tunneling for remote access"
                        ],
                        'remediation_effort': 'medium'
                    }
                    vulnerabilities.append(vulnerability)
            
            # Check SSL/TLS configuration
            ssl_issues = await self._check_ssl_config()
            vulnerabilities.extend(ssl_issues)
            
            self.logger.info(f"Found {len(vulnerabilities)} network security issues")
            return vulnerabilities
        
        except Exception as e:
            self.logger.error(f"Error scanning network security: {e}")
            return []
    
    async def _check_open_ports(self) -> List[Dict[str, Any]]:
        """Check for open network ports."""
        try:
            # In a real implementation, this would use netstat or ss
            # For demo, return some mock data
            return [
                {
                    'port': 22,
                    'service': 'SSH',
                    'risk_level': 'medium'
                },
                {
                    'port': 80,
                    'service': 'HTTP',
                    'risk_level': 'low'
                },
                {
                    'port': 443,
                    'service': 'HTTPS',
                    'risk_level': 'low'
                }
            ]
        except Exception as e:
            self.logger.error(f"Error checking open ports: {e}")
            return []
    
    async def _check_ssl_config(self) -> List[Dict[str, Any]]:
        """Check SSL/TLS configuration."""
        vulnerabilities = []
        
        try:
            # Check if SSL certificate files exist
            ssl_paths = [
                '/ssl/fullchain.pem',
                '/ssl/privkey.pem',
                '/config/ssl/fullchain.pem',
                '/config/ssl/privkey.pem'
            ]
            
            ssl_files_found = []
            for ssl_path in ssl_paths:
                if os.path.exists(ssl_path):
                    ssl_files_found.append(ssl_path)
                    
                    # Check certificate file permissions
                    file_stat = os.stat(ssl_path)
                    if 'privkey' in ssl_path and (file_stat.st_mode & stat.S_IROTH):
                        vulnerability = {
                            'title': 'SSL private key world-readable',
                            'description': f"SSL private key {ssl_path} is readable by all users",
                            'severity': 'critical',
                            'component': 'ssl',
                            'file': ssl_path,
                            'recommendations': [
                                f"Restrict private key access: chmod 600 {ssl_path}",
                                "Ensure SSL private keys are only accessible to necessary processes"
                            ],
                            'remediation_effort': 'low'
                        }
                        vulnerabilities.append(vulnerability)
            
            # Check if SSL is properly configured
            if not ssl_files_found:
                vulnerability = {
                    'title': 'No SSL certificates found',
                    'description': 'No SSL certificate files found - communications may not be encrypted',
                    'severity': 'medium',
                    'component': 'ssl',
                    'recommendations': [
                        "Configure SSL certificates for encrypted communications",
                        "Use Let's Encrypt or other certificate authority",
                        "Ensure all communications are encrypted in transit"
                    ],
                    'remediation_effort': 'medium'
                }
                vulnerabilities.append(vulnerability)
        
        except Exception as e:
            self.logger.error(f"Error checking SSL configuration: {e}")
        
        return vulnerabilities
    
    async def generate_vulnerability_report(self) -> Dict[str, Any]:
        """Generate comprehensive vulnerability report."""
        try:
            start_time = datetime.now()
            
            # Run all scans
            dependency_vulns = await self.scan_dependencies()
            config_vulns = await self.scan_configuration()
            permission_vulns = await self.scan_file_permissions()
            network_vulns = await self.scan_network_security()
            
            all_vulnerabilities = (
                dependency_vulns + config_vulns + 
                permission_vulns + network_vulns
            )
            
            # Categorize by severity
            severity_counts = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}
            for vuln in all_vulnerabilities:
                severity = vuln.get('severity', 'low')
                severity_counts[severity] += 1
            
            # Generate recommendations
            recommendations = []
            if severity_counts['critical'] > 0:
                recommendations.append("URGENT: Address critical vulnerabilities immediately")
            if severity_counts['high'] > 0:
                recommendations.append("Address high-severity vulnerabilities within 24 hours")
            if severity_counts['medium'] > 0:
                recommendations.append("Plan remediation for medium-severity vulnerabilities")
            
            # Calculate risk score
            risk_score = (
                severity_counts['critical'] * 10 +
                severity_counts['high'] * 5 +
                severity_counts['medium'] * 2 +
                severity_counts['low'] * 1
            )
            
            max_score = len(all_vulnerabilities) * 10
            risk_percentage = (risk_score / max(max_score, 1)) * 100
            
            duration = (datetime.now() - start_time).total_seconds()
            
            return {
                'scan_timestamp': start_time.isoformat(),
                'scan_duration_seconds': duration,
                'total_vulnerabilities': len(all_vulnerabilities),
                'severity_breakdown': severity_counts,
                'risk_score': risk_score,
                'risk_percentage': risk_percentage,
                'vulnerabilities': all_vulnerabilities,
                'recommendations': recommendations,
                'scan_coverage': {
                    'dependencies': len(dependency_vulns),
                    'configuration': len(config_vulns),
                    'permissions': len(permission_vulns),
                    'network': len(network_vulns)
                }
            }
        
        except Exception as e:
            self.logger.error(f"Error generating vulnerability report: {e}")
            return {}


# Example usage and testing
if __name__ == "__main__":
    import asyncio
    
    async def test_vulnerability_scanner():
        """Test vulnerability scanner functionality."""
        
        config = {}
        scanner = VulnerabilityScanner(config)
        
        # Test dependency scan
        print("Testing dependency scan...")
        dep_vulns = await scanner.scan_dependencies()
        print(f"Found {len(dep_vulns)} dependency vulnerabilities")
        
        # Test configuration scan
        print("Testing configuration scan...")
        config_vulns = await scanner.scan_configuration()
        print(f"Found {len(config_vulns)} configuration vulnerabilities")
        
        # Test permission scan
        print("Testing permission scan...")
        perm_vulns = await scanner.scan_file_permissions()
        print(f"Found {len(perm_vulns)} permission issues")
        
        # Generate full report
        print("Generating vulnerability report...")
        report = await scanner.generate_vulnerability_report()
        print(f"Total vulnerabilities: {report.get('total_vulnerabilities', 0)}")
        print(f"Risk score: {report.get('risk_score', 0)}")
        
        print("Vulnerability scanner test completed!")
    
    # Run test
    asyncio.run(test_vulnerability_scanner())