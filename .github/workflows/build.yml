name: Build Home Assistant Addon

on:
  push:
    branches:
      - main
    tags:
      - 'v*'
  pull_request:
    branches:
      - main
  release:
    types:
      - published

env:
  REGISTRY: ghcr.io

jobs:
  pre-build-validation:
    runs-on: ubuntu-latest
    name: Pre-build validation and configuration checks
    outputs:
      config_valid: ${{ steps.validate_config.outputs.config_valid }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install validation tools
        run: |
          sudo apt-get update && sudo apt-get install -y yq jq yamllint
          
      - name: Validate config.yaml syntax
        run: |
          cd aicleaner_v3
          echo "Validating config.yaml syntax..."
          if [ ! -f "config.yaml" ]; then
            echo "‚ùå config.yaml not found in aicleaner_v3 directory"
            exit 1
          fi
          
          # YAML syntax validation
          yamllint config.yaml || (echo "‚ùå config.yaml has syntax errors" && exit 1)
          
          # JSON conversion test
          yq eval -o=json config.yaml >/dev/null || (echo "‚ùå config.yaml cannot be converted to JSON" && exit 1)
          
          echo "‚úÖ config.yaml syntax is valid"

      - name: Validate required fields
        id: validate_config
        run: |
          cd aicleaner_v3
          echo "Validating required fields in config.yaml..."
          
          # Check for required fields
          NAME=$(yq eval '.name' config.yaml)
          VERSION=$(yq eval '.version' config.yaml)
          SLUG=$(yq eval '.slug' config.yaml)
          ARCH=$(yq eval '.arch' config.yaml)
          
          if [ "$NAME" = "null" ] || [ -z "$NAME" ]; then
            echo "‚ùå Missing or invalid 'name' field"
            exit 1
          fi
          
          if [ "$VERSION" = "null" ] || [ -z "$VERSION" ]; then
            echo "‚ùå Missing or invalid 'version' field"
            exit 1
          fi
          
          if [ "$SLUG" = "null" ] || [ -z "$SLUG" ]; then
            echo "‚ùå Missing or invalid 'slug' field"
            exit 1
          fi
          
          if [ "$ARCH" = "null" ] || [ "$ARCH" = "[]" ]; then
            echo "‚ùå Missing or invalid 'arch' field"
            exit 1
          fi
          
          # Validate architecture list
          ARCH_COUNT=$(yq eval '.arch | length' config.yaml)
          if [ "$ARCH_COUNT" -eq 0 ]; then
            echo "‚ùå Architecture list is empty"
            exit 1
          fi
          
          echo "‚úÖ All required fields are present and valid"
          echo "üìã Configuration summary:"
          echo "  Name: $NAME"
          echo "  Version: $VERSION"
          echo "  Slug: $SLUG"
          echo "  Architectures: $(yq eval '.arch | join(", ")' config.yaml)"
          
          echo "config_valid=true" >> $GITHUB_OUTPUT

  info:
    runs-on: ubuntu-latest
    name: Get addon information with multi-strategy fallback
    needs: pre-build-validation
    outputs:
      architectures: ${{ steps.determine_architectures.outputs.matrix_arch }}
      name: ${{ steps.get_info.outputs.name }}
      slug: ${{ steps.get_info.outputs.slug }}
      version: ${{ steps.get_info.outputs.version }}
      strategy_used: ${{ steps.determine_architectures.outputs.strategy_used }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install required tools
        run: |
          sudo apt-get update && sudo apt-get install -y yq jq

      - name: Try Home Assistant info action
        id: ha_info
        uses: home-assistant/actions/helpers/info@master
        with:
          path: ./aicleaner_v3
        continue-on-error: true

      - name: Get basic info from config.yaml
        id: get_info
        run: |
          cd aicleaner_v3
          NAME=$(yq eval '.name' config.yaml)
          VERSION=$(yq eval '.version' config.yaml)
          SLUG=$(yq eval '.slug' config.yaml)
          
          echo "name=$NAME" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "slug=$SLUG" >> $GITHUB_OUTPUT

      - name: Determine architectures with fallback strategy
        id: determine_architectures
        run: |
          cd aicleaner_v3
          ARCH_FINAL=""
          STRATEGY=""

          echo "=== Architecture Detection Strategy ==="
          
          # Strategy 1: Try Home Assistant info action output
          HA_ARCH="${{ steps.ha_info.outputs.architectures }}"
          HA_OUTCOME="${{ steps.ha_info.outcome }}"
          
          echo "‚ÑπÔ∏è  Home Assistant info action status: $HA_OUTCOME"
          echo "‚ÑπÔ∏è  Home Assistant info action output: '$HA_ARCH'"
          
          if [ "$HA_OUTCOME" == "success" ] && [ -n "$HA_ARCH" ] && [ "$HA_ARCH" != "null" ] && echo "$HA_ARCH" | jq -e . > /dev/null 2>&1; then
            # Validate it's not an empty array
            ARCH_COUNT=$(echo "$HA_ARCH" | jq '. | length')
            if [ "$ARCH_COUNT" -gt 0 ]; then
              echo "‚úÖ Strategy 1: Using architectures from Home Assistant info action"
              ARCH_FINAL="$HA_ARCH"
              STRATEGY="ha_info_action"
            else
              echo "‚ö†Ô∏è  Strategy 1 failed: Home Assistant info action returned empty array"
            fi
          else
            echo "‚ö†Ô∏è  Strategy 1 failed: Home Assistant info action failed or returned invalid data"
          fi

          # Strategy 2: Direct config.yaml parsing
          if [ -z "$ARCH_FINAL" ] || [ "$ARCH_FINAL" == "[]" ]; then
            echo "üîÑ Attempting Strategy 2: Direct config.yaml parsing"
            if [ -f "config.yaml" ]; then
              PARSED_ARCH=$(yq eval -o=json '.arch' config.yaml)
              echo "‚ÑπÔ∏è  Parsed architectures from config.yaml: '$PARSED_ARCH'"
              
              if [ -n "$PARSED_ARCH" ] && [ "$PARSED_ARCH" != "null" ] && echo "$PARSED_ARCH" | jq -e . > /dev/null 2>&1; then
                ARCH_COUNT=$(echo "$PARSED_ARCH" | jq '. | length')
                if [ "$ARCH_COUNT" -gt 0 ]; then
                  echo "‚úÖ Strategy 2: Using architectures from direct config.yaml parsing"
                  ARCH_FINAL="$PARSED_ARCH"
                  STRATEGY="direct_config_parsing"
                else
                  echo "‚ö†Ô∏è  Strategy 2 failed: Parsed architecture list is empty"
                fi
              else
                echo "‚ö†Ô∏è  Strategy 2 failed: Could not parse architectures from config.yaml"
              fi
            else
              echo "‚ö†Ô∏è  Strategy 2 failed: config.yaml not found"
            fi
          fi

          # Strategy 3: Hardcoded fallback with validation
          if [ -z "$ARCH_FINAL" ] || [ "$ARCH_FINAL" == "[]" ]; then
            echo "üîÑ Attempting Strategy 3: Hardcoded fallback with validation"
            HARDCODED_ARCH='["aarch64","amd64","armhf","armv7"]'
            
            # Try to validate against config.yaml if it exists
            if [ -f "config.yaml" ]; then
              CONFIG_ARCH=$(yq eval -o=json '.arch' config.yaml 2>/dev/null || echo "[]")
              if [ "$CONFIG_ARCH" != "[]" ] && [ "$CONFIG_ARCH" != "$HARDCODED_ARCH" ]; then
                echo "‚ö†Ô∏è  Warning: Hardcoded architectures may not match config.yaml"
                echo "    Config: $CONFIG_ARCH"
                echo "    Hardcoded: $HARDCODED_ARCH"
              fi
            fi
            
            echo "‚úÖ Strategy 3: Using hardcoded architectures as final fallback"
            ARCH_FINAL="$HARDCODED_ARCH"
            STRATEGY="hardcoded_fallback"
          fi

          # Final validation
          if [ -z "$ARCH_FINAL" ] || [ "$ARCH_FINAL" == "[]" ]; then
            echo "‚ùå CRITICAL ERROR: All architecture detection strategies failed"
            echo "This should never happen with the fallback system in place"
            exit 1
          fi

          # Validate final result
          if ! echo "$ARCH_FINAL" | jq -e . > /dev/null 2>&1; then
            echo "‚ùå CRITICAL ERROR: Final architecture result is not valid JSON: $ARCH_FINAL"
            exit 1
          fi

          FINAL_COUNT=$(echo "$ARCH_FINAL" | jq '. | length')
          if [ "$FINAL_COUNT" -eq 0 ]; then
            echo "‚ùå CRITICAL ERROR: Final architecture list is empty"
            exit 1
          fi

          echo "=== Final Result ==="
          echo "‚úÖ Strategy used: $STRATEGY"
          echo "‚úÖ Architectures for matrix: $ARCH_FINAL"
          echo "‚úÖ Architecture count: $FINAL_COUNT"
          echo "‚úÖ Individual architectures: $(echo "$ARCH_FINAL" | jq -r '.[]' | tr '\n' ' ')"
          
          echo "matrix_arch=$ARCH_FINAL" >> $GITHUB_OUTPUT
          echo "strategy_used=$STRATEGY" >> $GITHUB_OUTPUT

  validate-build:
    runs-on: ubuntu-latest
    name: Enhanced build configuration validation
    needs: [pre-build-validation, info]
    outputs:
      build_valid: ${{ steps.comprehensive_validation.outputs.build_valid }}
      dockerfile_secure: ${{ steps.security_check.outputs.dockerfile_secure }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install security and validation tools
        run: |
          sudo apt-get update && sudo apt-get install -y hadolint yq jq

      - name: Validate essential build files
        run: |
          cd aicleaner_v3
          echo "=== Essential Build Files Validation ==="
          
          MISSING_FILES=()
          
          # Check for required files
          if [ ! -f "Dockerfile" ]; then
            echo "‚ùå Dockerfile not found"
            MISSING_FILES+=("Dockerfile")
          else
            echo "‚úÖ Dockerfile found"
          fi
          
          if [ ! -f "config.yaml" ]; then
            echo "‚ùå config.yaml not found"
            MISSING_FILES+=("config.yaml")
          else
            echo "‚úÖ config.yaml found"
          fi
          
          if [ ! -f "run.sh" ]; then
            echo "‚ùå run.sh not found"
            MISSING_FILES+=("run.sh")
          else
            echo "‚úÖ run.sh found"
            # Check if run.sh is executable
            if [ ! -x "run.sh" ]; then
              echo "‚ö†Ô∏è  run.sh is not executable, this may cause issues"
            fi
          fi
          
          # Optional but recommended files
          if [ ! -f "requirements.txt" ]; then
            echo "‚ö†Ô∏è  requirements.txt not found (optional but recommended)"
          else
            echo "‚úÖ requirements.txt found"
          fi
          
          if [ ! -f "build.yaml" ]; then
            echo "‚ö†Ô∏è  build.yaml not found (may be optional)"
          else
            echo "‚úÖ build.yaml found"
          fi
          
          if [ ${#MISSING_FILES[@]} -gt 0 ]; then
            echo "‚ùå Missing required files: ${MISSING_FILES[*]}"
            exit 1
          fi
          
          echo "‚úÖ All essential build files are present"

      - name: Advanced Dockerfile security analysis
        id: security_check
        run: |
          cd aicleaner_v3
          echo "=== Dockerfile Security Analysis ==="
          
          SECURITY_ISSUES=0
          WARNINGS=()
          CRITICAL_ISSUES=()
          
          # Check for security anti-patterns
          if grep -q "USER root" Dockerfile; then
            echo "üîç Root user detected - checking if properly dropped later"
            if ! grep -q "USER " Dockerfile | tail -1 | grep -v "USER root"; then
              CRITICAL_ISSUES+=("Final USER is root - security risk")
              SECURITY_ISSUES=$((SECURITY_ISSUES + 1))
            fi
          fi
          
          # Check for exposed secrets
          if grep -iE "(password|secret|key|token).*=" Dockerfile; then
            CRITICAL_ISSUES+=("Potential secrets in Dockerfile")
            SECURITY_ISSUES=$((SECURITY_ISSUES + 1))
          fi
          
          # Check for dangerous commands
          if grep -E "(curl.*sh|wget.*sh|bash.*http)" Dockerfile; then
            WARNINGS+=("Downloading and executing scripts directly - potential security risk")
          fi
          
          # Check for proper base image
          if ! grep -q "FROM.*home-assistant.*base" Dockerfile; then
            WARNINGS+=("Not using official Home Assistant base image")
          fi
          
          # Run hadolint for additional security checks
          echo "üîç Running hadolint security analysis..."
          if ! docker run --rm -i hadolint/hadolint < Dockerfile; then
            WARNINGS+=("Hadolint detected potential issues")
          fi
          
          # Report results
          if [ ${#CRITICAL_ISSUES[@]} -gt 0 ]; then
            echo "‚ùå Critical security issues found:"
            printf '  - %s\n' "${CRITICAL_ISSUES[@]}"
            echo "dockerfile_secure=false" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ No critical security issues found"
            echo "dockerfile_secure=true" >> $GITHUB_OUTPUT
          fi
          
          if [ ${#WARNINGS[@]} -gt 0 ]; then
            echo "‚ö†Ô∏è  Security warnings:"
            printf '  - %s\n' "${WARNINGS[@]}"
          fi
          
          if [ $SECURITY_ISSUES -gt 0 ]; then
            echo "‚ùå $SECURITY_ISSUES critical security issue(s) must be fixed before proceeding"
            exit 1
          fi

      - name: Validate matrix architecture consistency
        run: |
          cd aicleaner_v3
          echo "=== Matrix Architecture Consistency Check ==="
          
          # Get architectures from different sources
          CONFIG_ARCH=$(yq eval -o=json '.arch' config.yaml 2>/dev/null || echo "[]")
          MATRIX_ARCH="${{ needs.info.outputs.architectures }}"
          STRATEGY_USED="${{ needs.info.outputs.strategy_used }}"
          
          echo "‚ÑπÔ∏è  Strategy used for architecture detection: $STRATEGY_USED"
          echo "‚ÑπÔ∏è  Architectures from config.yaml: $CONFIG_ARCH"
          echo "‚ÑπÔ∏è  Architectures for matrix: $MATRIX_ARCH"
          
          # Validate matrix architectures are not empty
          if [ -z "$MATRIX_ARCH" ] || [ "$MATRIX_ARCH" == "[]" ]; then
            echo "‚ùå Matrix architectures are empty - this should not happen"
            exit 1
          fi
          
          # Count architectures
          MATRIX_COUNT=$(echo "$MATRIX_ARCH" | jq '. | length')
          echo "‚ÑπÔ∏è  Number of architectures in matrix: $MATRIX_COUNT"
          
          if [ "$MATRIX_COUNT" -eq 0 ]; then
            echo "‚ùå No architectures in matrix"
            exit 1
          fi
          
          # Validate each architecture is supported
          echo "$MATRIX_ARCH" | jq -r '.[]' | while read -r arch; do
            case $arch in
              aarch64|amd64|armhf|armv7)
                echo "‚úÖ Architecture '$arch' is supported"
                ;;
              *)
                echo "‚ö†Ô∏è  Architecture '$arch' may not be supported by Home Assistant"
                ;;
            esac
          done
          
          echo "‚úÖ Matrix architecture consistency check passed"

      - name: Comprehensive validation summary
        id: comprehensive_validation
        run: |
          echo "=== Build Validation Summary ==="
          echo "Configuration valid: ${{ needs.pre-build-validation.outputs.config_valid }}"
          echo "Dockerfile secure: ${{ steps.security_check.outputs.dockerfile_secure }}"
          echo "Architecture strategy: ${{ needs.info.outputs.strategy_used }}"
          echo "Architecture count: $(echo '${{ needs.info.outputs.architectures }}' | jq '. | length')"
          
          # Final validation decision
          if [ "${{ needs.pre-build-validation.outputs.config_valid }}" == "true" ] && [ "${{ steps.security_check.outputs.dockerfile_secure }}" == "true" ]; then
            echo "‚úÖ All validations passed - build can proceed"
            echo "build_valid=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Validation failures detected - build should not proceed"
            echo "build_valid=false" >> $GITHUB_OUTPUT
            exit 1
          fi

  build:
    runs-on: ubuntu-latest
    name: Enhanced build for ${{ matrix.arch }} with error recovery
    needs: [pre-build-validation, info, validate-build]
    if: needs.validate-build.outputs.build_valid == 'true'
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
    strategy:
      fail-fast: false
      matrix:
        arch: ${{ fromJson(needs.info.outputs.architectures) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build environment setup and validation
        run: |
          echo "=== Build Environment Setup ==="
          echo "Architecture: ${{ matrix.arch }}"
          echo "Registry: ${{ env.REGISTRY }}"
          echo "Strategy used: ${{ needs.info.outputs.strategy_used }}"
          echo "Addon slug: ${{ needs.info.outputs.slug }}"
          echo "Addon version: ${{ needs.info.outputs.version }}"
          
          # Validate environment
          if [ -z "${{ matrix.arch }}" ]; then
            echo "‚ùå Matrix architecture is empty"
            exit 1
          fi
          
          if [ -z "${{ needs.info.outputs.slug }}" ]; then
            echo "‚ùå Addon slug is empty"
            exit 1
          fi
          
          echo "‚úÖ Build environment validation passed"

      - name: Set up Docker Buildx with retry
        uses: docker/setup-buildx-action@v3
        with:
          platforms: linux/${{ matrix.arch }}
          retry-delay: 5
          retry-on-error: true

      - name: Login to GitHub Container Registry with retry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}
        env:
          DOCKER_LOGIN_RETRY: 3

      - name: Extract metadata with validation
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ needs.info.outputs.slug }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
          labels: |
            org.opencontainers.image.title=${{ needs.info.outputs.name }}
            org.opencontainers.image.description=AICleaner V3 Home Assistant Addon
            org.opencontainers.image.version=${{ needs.info.outputs.version }}
            org.opencontainers.image.architecture=${{ matrix.arch }}
            io.hass.addon=true
            io.hass.arch=${{ matrix.arch }}

      - name: Validate extracted metadata
        run: |
          echo "=== Docker Metadata Validation ==="
          echo "Generated tags: ${{ steps.meta.outputs.tags }}"
          echo "Generated labels: ${{ steps.meta.outputs.labels }}"
          
          if [ -z "${{ steps.meta.outputs.tags }}" ]; then
            echo "‚ùå No Docker tags generated"
            exit 1
          fi
          
          echo "‚úÖ Docker metadata validation passed"

      - name: Setup Docker layer caching with cleanup
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ matrix.arch }}-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-${{ matrix.arch }}-
            ${{ runner.os }}-buildx-

      - name: Pre-build Docker environment check
        run: |
          echo "=== Docker Environment Check ==="
          docker version
          docker buildx version
          docker buildx ls
          
          # Check available disk space
          df -h
          
          # Clean up any stale containers or images
          docker system prune -f || true
          
          echo "‚úÖ Docker environment check completed"

      - name: Build addon with enhanced error handling
        id: build_addon
        run: |
          echo "=== Starting Addon Build ==="
          BUILD_FAILED=false
          
          # First attempt
          echo "üèóÔ∏è  Attempting build (attempt 1/3)..."
          if ! docker run --rm --privileged \
            -v /var/run/docker.sock:/var/run/docker.sock:ro \
            -v "${{ github.workspace }}:/data" \
            -v /tmp/.buildx-cache:/cache \
            ghcr.io/home-assistant/amd64-builder:latest \
            --target /data/aicleaner_v3 \
            --${{ matrix.arch }} \
            --docker-hub ${{ env.REGISTRY }} \
            --image "${{ needs.info.outputs.slug }}" \
            --cache-from "type=local,src=/cache" \
            --cache-to "type=local,dest=/tmp/.buildx-cache-new,mode=max"; then
            
            echo "‚ö†Ô∏è  Build attempt 1 failed, trying alternative approach..."
            BUILD_FAILED=true
            
            # Second attempt with Home Assistant builder action
            echo "üèóÔ∏è  Attempting build with HA builder action (attempt 2/3)..."
            if ! docker run --rm --privileged \
              -v /var/run/docker.sock:/var/run/docker.sock:ro \
              -v "${{ github.workspace }}:/data" \
              ghcr.io/home-assistant/amd64-builder:latest \
              --target /data/aicleaner_v3 \
              --${{ matrix.arch }} \
              --docker-hub ${{ env.REGISTRY }} \
              --image "${{ needs.info.outputs.slug }}"; then
              
              echo "‚ö†Ô∏è  Build attempt 2 failed, trying minimal build..."
              
              # Third attempt with direct docker build
              echo "üèóÔ∏è  Attempting direct docker build (attempt 3/3)..."
              cd aicleaner_v3
              if ! docker buildx build \
                --platform linux/${{ matrix.arch }} \
                --tag ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ needs.info.outputs.slug }}:${{ needs.info.outputs.version }}-${{ matrix.arch }} \
                --push \
                .; then
                echo "‚ùå All build attempts failed"
                exit 1
              else
                echo "‚úÖ Direct docker build succeeded"
                BUILD_FAILED=false
              fi
            else
              echo "‚úÖ HA builder action succeeded"
              BUILD_FAILED=false
            fi
          else
            echo "‚úÖ Initial build succeeded"
          fi
          
          if [ "$BUILD_FAILED" = "true" ]; then
            echo "build_status=failed" >> $GITHUB_OUTPUT
          else
            echo "build_status=success" >> $GITHUB_OUTPUT
          fi

      - name: Verify build success
        run: |
          if [ "${{ steps.build_addon.outputs.build_status }}" != "success" ]; then
            echo "‚ùå Build verification failed"
            exit 1
          fi
          
          echo "‚úÖ Build completed successfully for ${{ matrix.arch }}"

      - name: Optimize Docker cache management
        run: |
          echo "=== Docker Cache Management ==="
          
          # Clean up old cache if new cache exists
          if [ -d "/tmp/.buildx-cache-new" ]; then
            echo "Moving new cache to main cache location..."
            rm -rf /tmp/.buildx-cache || true
            mv /tmp/.buildx-cache-new /tmp/.buildx-cache
            echo "‚úÖ Cache management completed"
          else
            echo "‚ÑπÔ∏è  No new cache to manage"
          fi
          
          # Clean up Docker system to free space
          docker system prune -f --volumes || true
          
          # Show remaining disk space
          df -h

      - name: Build summary and artifact generation
        if: success()
        run: |
          echo "=== Build Summary ==="
          echo "‚úÖ Architecture: ${{ matrix.arch }}"
          echo "‚úÖ Strategy: ${{ needs.info.outputs.strategy_used }}"
          echo "‚úÖ Version: ${{ needs.info.outputs.version }}"
          echo "‚úÖ Registry: ${{ env.REGISTRY }}"
          echo "‚úÖ Status: Success"
          
          # Create build artifact info
          mkdir -p build-artifacts
          cat > build-artifacts/build-info-${{ matrix.arch }}.json << EOF
          {
            "architecture": "${{ matrix.arch }}",
            "version": "${{ needs.info.outputs.version }}",
            "slug": "${{ needs.info.outputs.slug }}",
            "strategy_used": "${{ needs.info.outputs.strategy_used }}",
            "build_time": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "registry": "${{ env.REGISTRY }}",
            "tags": "${{ steps.meta.outputs.tags }}",
            "status": "success"
          }
          EOF

      - name: Upload build artifacts
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: build-info-${{ matrix.arch }}
          path: build-artifacts/build-info-${{ matrix.arch }}.json
          retention-days: 30

  test-build:
    runs-on: ubuntu-latest
    name: Comprehensive testing of built images
    needs: [pre-build-validation, info, validate-build, build]
    if: github.event_name == 'pull_request' || github.event_name == 'push'
    strategy:
      matrix:
        arch: [amd64]  # Test primary architecture only for efficiency
        test_type: [startup, security, functionality]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up testing environment
        run: |
          echo "=== Testing Environment Setup ==="
          echo "Architecture: ${{ matrix.arch }}"
          echo "Test type: ${{ matrix.test_type }}"
          echo "Addon version: ${{ needs.info.outputs.version }}"
          
          # Install testing tools
          sudo apt-get update && sudo apt-get install -y curl jq

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build test image with enhanced validation
        run: |
          cd aicleaner_v3
          echo "=== Building Test Image ==="
          
          # Build image for testing
          if ! docker buildx build \
            --platform linux/${{ matrix.arch }} \
            --load \
            --tag test-aicleaner:${{ needs.info.outputs.version }} \
            --tag test-aicleaner:latest \
            .; then
            echo "‚ùå Test image build failed"
            exit 1
          fi
          
          # Verify image was created
          docker images test-aicleaner:latest
          echo "‚úÖ Test image built successfully"

      - name: Basic image inspection
        run: |
          echo "=== Image Inspection ==="
          
          # Get image details
          IMAGE_ID=$(docker images test-aicleaner:latest -q)
          echo "Image ID: $IMAGE_ID"
          
          # Inspect image
          docker inspect test-aicleaner:latest | jq '.[0].Config.Labels'
          
          # Check image size
          IMAGE_SIZE=$(docker images test-aicleaner:latest --format "table {{.Size}}" | tail -1)
          echo "Image size: $IMAGE_SIZE"
          
          echo "‚úÖ Image inspection completed"

      - name: Container startup and health tests
        if: matrix.test_type == 'startup'
        run: |
          echo "=== Container Startup Tests ==="
          
          # Test 1: Basic startup
          echo "üß™ Test 1: Basic container startup"
          if timeout 60 docker run --rm --name test-startup \
            -e LOG_LEVEL=debug \
            -e DEBUG_MODE=true \
            test-aicleaner:latest /bin/sh -c "echo 'Container started successfully' && sleep 5"; then
            echo "‚úÖ Basic startup test passed"
          else
            echo "‚ùå Basic startup test failed"
            exit 1
          fi
          
          # Test 2: Environment variable handling
          echo "üß™ Test 2: Environment variable handling"
          if docker run --rm --name test-env \
            -e LOG_LEVEL=info \
            -e DEVICE_ID=test_device \
            test-aicleaner:latest /bin/sh -c "printenv | grep -E '(LOG_LEVEL|DEVICE_ID)' && echo 'Environment test passed'"; then
            echo "‚úÖ Environment variable test passed"
          else
            echo "‚ö†Ô∏è  Environment variable test had issues (non-critical)"
          fi
          
          # Test 3: File system access
          echo "üß™ Test 3: File system access test"
          if docker run --rm --name test-fs \
            -v /tmp/test-data:/data \
            test-aicleaner:latest /bin/sh -c "touch /data/test.txt && ls -la /data/ && rm /data/test.txt"; then
            echo "‚úÖ File system access test passed"
          else
            echo "‚ö†Ô∏è  File system access test failed (may be expected)"
          fi
          
          echo "‚úÖ All startup tests completed"

      - name: Security vulnerability scanning
        if: matrix.test_type == 'security'
        run: |
          echo "=== Security Vulnerability Scanning ==="
          
          # Install trivy if not available
          if ! command -v trivy &> /dev/null; then
            echo "Installing Trivy..."
            sudo apt-get update && sudo apt-get install -y wget apt-transport-https gnupg lsb-release
            wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
            echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
            sudo apt-get update && sudo apt-get install -y trivy
          fi
          
          # Run security scan
          echo "üîç Running Trivy security scan..."
          if trivy image --exit-code 0 --severity HIGH,CRITICAL --format table test-aicleaner:latest; then
            echo "‚úÖ Security scan completed - no critical vulnerabilities found"
          else
            echo "‚ö†Ô∏è  Security scan found potential issues (see above)"
            # Don't fail the build for security warnings in testing
          fi
          
          # Check for known security anti-patterns
          echo "üîç Checking for security anti-patterns..."
          
          # Check if running as root
          ROOT_CHECK=$(docker run --rm test-aicleaner:latest /bin/sh -c "whoami" 2>/dev/null || echo "unknown")
          if [ "$ROOT_CHECK" = "root" ]; then
            echo "‚ö†Ô∏è  Container running as root user"
          else
            echo "‚úÖ Container not running as root: $ROOT_CHECK"
          fi
          
          echo "‚úÖ Security testing completed"

      - name: Functionality and integration tests
        if: matrix.test_type == 'functionality'
        run: |
          echo "=== Functionality Tests ==="
          
          # Test 1: Check if required directories exist
          echo "üß™ Test 1: Directory structure"
          docker run --rm test-aicleaner:latest /bin/sh -c "ls -la / && echo 'Directory check completed'" || true
          
          # Test 2: Check Python environment (if applicable)
          echo "üß™ Test 2: Python environment"
          if docker run --rm test-aicleaner:latest /bin/sh -c "python3 --version && pip3 --version"; then
            echo "‚úÖ Python environment test passed"
          else
            echo "‚ö†Ô∏è  Python environment test failed (may not be Python-based)"
          fi
          
          # Test 3: Check for required files
          echo "üß™ Test 3: Required files check"
          docker run --rm test-aicleaner:latest /bin/sh -c "ls -la /usr/bin/run.sh || ls -la /run.sh || echo 'Run script location varies'" || true
          
          # Test 4: Memory and resource usage
          echo "üß™ Test 4: Resource usage test"
          CONTAINER_ID=$(docker run -d --name test-resources test-aicleaner:latest sleep 30)
          sleep 5
          docker stats --no-stream test-resources
          docker stop test-resources
          docker rm test-resources
          
          echo "‚úÖ Functionality testing completed"

      - name: Generate test report
        if: always()
        run: |
          echo "=== Test Report Generation ==="
          
          # Create test report
          mkdir -p test-reports
          cat > test-reports/test-report-${{ matrix.arch }}-${{ matrix.test_type }}.json << EOF
          {
            "test_type": "${{ matrix.test_type }}",
            "architecture": "${{ matrix.arch }}",
            "addon_version": "${{ needs.info.outputs.version }}",
            "test_time": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "status": "${{ job.status }}",
            "github_event": "${{ github.event_name }}",
            "commit_sha": "${{ github.sha }}"
          }
          EOF
          
          echo "‚úÖ Test report generated"

      - name: Upload test reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-report-${{ matrix.arch }}-${{ matrix.test_type }}
          path: test-reports/test-report-${{ matrix.arch }}-${{ matrix.test_type }}.json
          retention-days: 30

      - name: Cleanup test resources
        if: always()
        run: |
          echo "=== Cleanup Test Resources ==="
          
          # Remove test images
          docker rmi test-aicleaner:latest test-aicleaner:${{ needs.info.outputs.version }} || true
          
          # Clean up any remaining containers
          docker container prune -f || true
          
          # Clean up system
          docker system prune -f || true
          
          echo "‚úÖ Cleanup completed"

  publish:
    runs-on: ubuntu-latest
    name: Enhanced publishing with validation and monitoring
    needs: [pre-build-validation, info, validate-build, build]
    if: needs.validate-build.outputs.build_valid == 'true' && (github.event_name == 'release' || (github.event_name == 'push' && github.ref == 'refs/heads/main'))
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: build-info-*
          path: build-artifacts
          merge-multiple: true

      - name: Validate build artifacts
        run: |
          echo "=== Build Artifacts Validation ==="
          
          # Check if all architecture builds completed successfully
          EXPECTED_ARCHS=$(echo '${{ needs.info.outputs.architectures }}' | jq -r '.[]')
          MISSING_ARCHS=()
          
          for arch in $EXPECTED_ARCHS; do
            if [ ! -f "build-artifacts/build-info-${arch}.json" ]; then
              MISSING_ARCHS+=("$arch")
              echo "‚ùå Missing build artifact for architecture: $arch"
            else
              BUILD_STATUS=$(jq -r '.status' "build-artifacts/build-info-${arch}.json")
              if [ "$BUILD_STATUS" != "success" ]; then
                echo "‚ùå Build failed for architecture: $arch (status: $BUILD_STATUS)"
                MISSING_ARCHS+=("$arch")
              else
                echo "‚úÖ Build succeeded for architecture: $arch"
              fi
            fi
          done
          
          if [ ${#MISSING_ARCHS[@]} -gt 0 ]; then
            echo "‚ùå Cannot publish - missing or failed builds for: ${MISSING_ARCHS[*]}"
            exit 1
          fi
          
          echo "‚úÖ All required architecture builds are present and successful"

      - name: Login to GitHub Container Registry with retry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify published images
        run: |
          echo "=== Published Images Verification ==="
          
          # Check if images exist in registry
          EXPECTED_ARCHS=$(echo '${{ needs.info.outputs.architectures }}' | jq -r '.[]')
          
          for arch in $EXPECTED_ARCHS; do
            IMAGE_TAG="${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ needs.info.outputs.slug }}:${{ needs.info.outputs.version }}-${arch}"
            echo "üîç Checking image: $IMAGE_TAG"
            
            # Try to pull the image to verify it exists
            if docker manifest inspect "$IMAGE_TAG" >/dev/null 2>&1; then
              echo "‚úÖ Image exists: $IMAGE_TAG"
            else
              echo "‚ö†Ô∏è  Image may not be published yet: $IMAGE_TAG"
            fi
          done

      - name: Generate comprehensive build summary
        run: |
          echo "=== Comprehensive Build Summary ===" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üìã Build Information" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: \`${{ needs.info.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Slug**: \`${{ needs.info.outputs.slug }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Strategy Used**: \`${{ needs.info.outputs.strategy_used }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Registry**: \`${{ env.REGISTRY }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Type**: \`${{ github.event_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "## üèóÔ∏è Architecture Status" >> $GITHUB_STEP_SUMMARY
          EXPECTED_ARCHS=$(echo '${{ needs.info.outputs.architectures }}' | jq -r '.[]')
          for arch in $EXPECTED_ARCHS; do
            if [ -f "build-artifacts/build-info-${arch}.json" ]; then
              BUILD_TIME=$(jq -r '.build_time' "build-artifacts/build-info-${arch}.json")
              echo "- **${arch}**: ‚úÖ Success (Built: $BUILD_TIME)" >> $GITHUB_STEP_SUMMARY
            else
              echo "- **${arch}**: ‚ùå Failed or Missing" >> $GITHUB_STEP_SUMMARY
            fi
          done
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "## üöÄ Installation Commands" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "# Add the repository to Home Assistant" >> $GITHUB_STEP_SUMMARY
          echo "# Navigate to Home Assistant > Supervisor > Add-on Store > ‚ãÆ > Repositories" >> $GITHUB_STEP_SUMMARY
          echo "# Add: https://github.com/${{ github.repository_owner }}/aicleaner_v3" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "## üîó Docker Images" >> $GITHUB_STEP_SUMMARY
          for arch in $EXPECTED_ARCHS; do
            IMAGE_TAG="${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ needs.info.outputs.slug }}:${{ needs.info.outputs.version }}-${arch}"
            echo "- **${arch}**: \`$IMAGE_TAG\`" >> $GITHUB_STEP_SUMMARY
          done

      - name: Create release assets for GitHub releases
        if: github.event_name == 'release'
        run: |
          echo "=== Creating Release Assets ==="
          cd aicleaner_v3
          
          # Create comprehensive release package
          echo "üì¶ Creating release package..."
          tar -czf "../aicleaner_v3-${{ needs.info.outputs.version }}.tar.gz" \
            --exclude='.git*' \
            --exclude='__pycache__' \
            --exclude='*.pyc' \
            --exclude='node_modules' \
            --exclude='.pytest_cache' \
            --exclude='test-*' \
            --exclude='*.log' \
            .
          
          cd ..
          
          # Generate checksums
          echo "üîê Generating checksums..."
          sha256sum "aicleaner_v3-${{ needs.info.outputs.version }}.tar.gz" > checksums.txt
          
          # Create installation guide
          cat > INSTALLATION.md << EOF
          # AICleaner V3 Installation Guide
          
          ## Version: ${{ needs.info.outputs.version }}
          ## Build Date: $(date -u +%Y-%m-%d)
          
          ### Supported Architectures:
          $(echo '${{ needs.info.outputs.architectures }}' | jq -r '.[]' | sed 's/^/- /')
          
          ### Installation Steps:
          1. Navigate to Home Assistant > Supervisor > Add-on Store
          2. Click the ‚ãÆ menu and select "Repositories"
          3. Add repository URL: \`https://github.com/${{ github.repository_owner }}/aicleaner_v3\`
          4. Find "AICleaner V3" in the add-on store
          5. Click "Install"
          6. Configure the add-on options
          7. Start the add-on
          
          ### Configuration:
          See the addon configuration documentation for detailed setup instructions.
          
          ### Build Information:
          - Strategy: ${{ needs.info.outputs.strategy_used }}
          - Commit: ${{ github.sha }}
          - Registry: ${{ env.REGISTRY }}
          EOF
          
          # Show created files
          ls -la *.tar.gz *.txt *.md
          echo "‚úÖ Release assets created successfully"

      - name: Upload release assets
        if: github.event_name == 'release'
        uses: actions/upload-artifact@v4
        with:
          name: release-assets
          path: |
            *.tar.gz
            checksums.txt
            INSTALLATION.md
          retention-days: 90

      - name: Create deployment notification
        if: success()
        run: |
          echo "=== Deployment Notification ==="
          
          # Create deployment summary
          cat > deployment-summary.json << EOF
          {
            "deployment_type": "${{ github.event_name }}",
            "version": "${{ needs.info.outputs.version }}",
            "slug": "${{ needs.info.outputs.slug }}",
            "architectures": ${{ needs.info.outputs.architectures }},
            "strategy_used": "${{ needs.info.outputs.strategy_used }}",
            "registry": "${{ env.REGISTRY }}",
            "commit": "${{ github.sha }}",
            "deployment_time": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "status": "success"
          }
          EOF
          
          echo "üìä Deployment Summary:"
          cat deployment-summary.json | jq .
          
          echo "‚úÖ Publishing completed successfully"

  post-build:
    runs-on: ubuntu-latest
    name: Post-build monitoring, cleanup, and comprehensive reporting
    needs: [pre-build-validation, info, validate-build, build, test-build, publish]
    if: always()
    steps:
      - name: Checkout for final operations
        uses: actions/checkout@v4

      - name: Download all artifacts for analysis
        uses: actions/download-artifact@v4
        with:
          path: all-artifacts
        continue-on-error: true

      - name: Comprehensive build status analysis
        run: |
          echo "=== Comprehensive Build Analysis ===" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üìä Overall Status" >> $GITHUB_STEP_SUMMARY
          
          # Analyze each job result
          OVERALL_STATUS="‚úÖ SUCCESS"
          FAILED_JOBS=()
          
          # Check each job
          if [ "${{ needs.pre-build-validation.result }}" != "success" ]; then
            FAILED_JOBS+=("pre-build-validation")
            OVERALL_STATUS="‚ùå FAILED"
          fi
          
          if [ "${{ needs.info.result }}" != "success" ]; then
            FAILED_JOBS+=("info")
            OVERALL_STATUS="‚ùå FAILED"
          fi
          
          if [ "${{ needs.validate-build.result }}" != "success" ]; then
            FAILED_JOBS+=("validate-build")
            OVERALL_STATUS="‚ùå FAILED"
          fi
          
          if [ "${{ needs.build.result }}" != "success" ]; then
            FAILED_JOBS+=("build")
            OVERALL_STATUS="‚ùå FAILED"
          fi
          
          if [ "${{ needs.test-build.result }}" != "success" ] && [ "${{ needs.test-build.result }}" != "skipped" ]; then
            FAILED_JOBS+=("test-build")
            OVERALL_STATUS="‚ö†Ô∏è TESTS FAILED"
          fi
          
          if [ "${{ needs.publish.result }}" != "success" ] && [ "${{ needs.publish.result }}" != "skipped" ]; then
            FAILED_JOBS+=("publish")
            OVERALL_STATUS="‚ùå PUBLISH FAILED"
          fi
          
          echo "**Overall Status**: $OVERALL_STATUS" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Detailed job status
          echo "## üîç Job Results" >> $GITHUB_STEP_SUMMARY
          echo "| Job | Status | Duration |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|--------|----------|" >> $GITHUB_STEP_SUMMARY
          
          jobs=("pre-build-validation" "info" "validate-build" "build" "test-build" "publish")
          for job in "${jobs[@]}"; do
            case $job in
              "pre-build-validation")
                result="${{ needs.pre-build-validation.result }}"
                ;;
              "info")
                result="${{ needs.info.result }}"
                ;;
              "validate-build")
                result="${{ needs.validate-build.result }}"
                ;;
              "build")
                result="${{ needs.build.result }}"
                ;;
              "test-build")
                result="${{ needs.test-build.result }}"
                ;;
              "publish")
                result="${{ needs.publish.result }}"
                ;;
            esac
            
            case $result in
              "success")
                status_icon="‚úÖ"
                ;;
              "failure")
                status_icon="‚ùå"
                ;;
              "cancelled")
                status_icon="üö´"
                ;;
              "skipped")
                status_icon="‚è≠Ô∏è"
                ;;
              *)
                status_icon="‚ùì"
                ;;
            esac
            
            echo "| $job | $status_icon $result | N/A |" >> $GITHUB_STEP_SUMMARY
          done
          
          # Failed jobs details
          if [ ${#FAILED_JOBS[@]} -gt 0 ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## ‚ùå Failed Jobs" >> $GITHUB_STEP_SUMMARY
            for failed_job in "${FAILED_JOBS[@]}"; do
              echo "- **$failed_job**: Investigation required" >> $GITHUB_STEP_SUMMARY
            done
          fi

      - name: Artifact analysis and reporting
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üì¶ Build Artifacts" >> $GITHUB_STEP_SUMMARY
          
          if [ -d "all-artifacts" ]; then
            echo "Generated artifacts:" >> $GITHUB_STEP_SUMMARY
            find all-artifacts -type f -name "*.json" | while read -r file; do
              filename=$(basename "$file")
              echo "- **$filename**" >> $GITHUB_STEP_SUMMARY
            done
            
            # Count architectures built successfully
            SUCCESSFUL_BUILDS=$(find all-artifacts -name "build-info-*.json" -exec grep -l '"status": "success"' {} \; | wc -l)
            TOTAL_EXPECTED=$(echo '${{ needs.info.outputs.architectures }}' | jq '. | length' 2>/dev/null || echo "0")
            
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Build Success Rate**: $SUCCESSFUL_BUILDS/$TOTAL_EXPECTED architectures" >> $GITHUB_STEP_SUMMARY
          else
            echo "No artifacts found (may indicate early failure)" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Performance metrics and optimization recommendations
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ‚ö° Performance Analysis" >> $GITHUB_STEP_SUMMARY
          
          # Calculate workflow duration (approximate)
          WORKFLOW_START=$(date -d "${{ github.event.head_commit.timestamp || github.event.created_at }}" +%s 2>/dev/null || echo "0")
          CURRENT_TIME=$(date +%s)
          DURATION=$((CURRENT_TIME - WORKFLOW_START))
          DURATION_MIN=$((DURATION / 60))
          
          if [ $DURATION_MIN -gt 0 ]; then
            echo "- **Estimated Duration**: ~${DURATION_MIN} minutes" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "- **Strategy Used**: ${{ needs.info.outputs.strategy_used }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Trigger Event**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          
          # Optimization recommendations
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üöÄ Optimization Notes" >> $GITHUB_STEP_SUMMARY
          if [ "${{ needs.info.outputs.strategy_used }}" = "hardcoded_fallback" ]; then
            echo "- ‚ö†Ô∏è Used fallback strategy - consider fixing Home Assistant info action" >> $GITHUB_STEP_SUMMARY
          fi
          if [ "${{ needs.build.result }}" = "success" ]; then
            echo "- ‚úÖ Multi-strategy fallback system working correctly" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Error analysis and troubleshooting guide
        if: contains(needs.*.result, 'failure')
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üîß Troubleshooting Guide" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.pre-build-validation.result }}" = "failure" ]; then
            echo "### Pre-build Validation Failed" >> $GITHUB_STEP_SUMMARY
            echo "- Check config.yaml syntax and required fields" >> $GITHUB_STEP_SUMMARY
            echo "- Verify all architecture entries are valid" >> $GITHUB_STEP_SUMMARY
            echo "- Ensure build.yaml exists and is properly formatted" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${{ needs.info.result }}" = "failure" ]; then
            echo "### Info Job Failed" >> $GITHUB_STEP_SUMMARY
            echo "- All fallback strategies failed to detect architectures" >> $GITHUB_STEP_SUMMARY
            echo "- Check Home Assistant info action compatibility" >> $GITHUB_STEP_SUMMARY
            echo "- Verify config.yaml is in correct location (./aicleaner_v3/)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${{ needs.build.result }}" = "failure" ]; then
            echo "### Build Job Failed" >> $GITHUB_STEP_SUMMARY
            echo "- Check Dockerfile syntax and base image availability" >> $GITHUB_STEP_SUMMARY
            echo "- Verify all dependencies are properly specified" >> $GITHUB_STEP_SUMMARY
            echo "- Check GitHub Container Registry permissions" >> $GITHUB_STEP_SUMMARY
            echo "- Review Docker buildx setup and cache issues" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "### General Recovery Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Check the detailed logs for each failed job" >> $GITHUB_STEP_SUMMARY
          echo "2. Verify all required files are present and valid" >> $GITHUB_STEP_SUMMARY
          echo "3. Test the build locally using the same Docker commands" >> $GITHUB_STEP_SUMMARY
          echo "4. Check for any breaking changes in dependencies" >> $GITHUB_STEP_SUMMARY

      - name: Comprehensive cleanup operations
        if: always()
        run: |
          echo "=== Comprehensive Cleanup Operations ==="
          
          # Docker cleanup
          echo "üßπ Cleaning Docker resources..."
          docker system prune -af --volumes || true
          docker buildx prune -af || true
          
          # Cache cleanup on failure
          if [ "${{ needs.build.result }}" = "failure" ]; then
            echo "üóëÔ∏è Cleaning potentially corrupted caches..."
            rm -rf /tmp/.buildx-cache* || true
          fi
          
          # Cleanup artifacts directory
          if [ -d "all-artifacts" ]; then
            echo "üì¶ Analyzing artifacts before cleanup..."
            find all-artifacts -type f | wc -l | xargs echo "Total artifact files:"
            # Keep artifacts for successful builds, clean up failed ones
            if [ "${{ needs.build.result }}" = "failure" ]; then
              rm -rf all-artifacts || true
              echo "üóëÔ∏è Cleaned up failed build artifacts"
            fi
          fi
          
          echo "‚úÖ Cleanup operations completed"

      - name: Generate final workflow report
        if: always()
        run: |
          echo "=== Final Workflow Report ==="
          
          # Create comprehensive report
          cat > workflow-report.json << EOF
          {
            "workflow_id": "${{ github.run_id }}",
            "workflow_number": "${{ github.run_number }}",
            "commit": "${{ github.sha }}",
            "event": "${{ github.event_name }}",
            "ref": "${{ github.ref }}",
            "actor": "${{ github.actor }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "jobs": {
              "pre_build_validation": "${{ needs.pre-build-validation.result }}",
              "info": "${{ needs.info.result }}",
              "validate_build": "${{ needs.validate-build.result }}",
              "build": "${{ needs.build.result }}",
              "test_build": "${{ needs.test-build.result }}",
              "publish": "${{ needs.publish.result }}"
            },
            "addon": {
              "version": "${{ needs.info.outputs.version }}",
              "slug": "${{ needs.info.outputs.slug }}",
              "strategy_used": "${{ needs.info.outputs.strategy_used }}",
              "architectures": ${{ needs.info.outputs.architectures || '[]' }}
            },
            "overall_status": "$([ "${{ needs.build.result }}" = "success" ] && echo "success" || echo "failure")"
          }
          EOF
          
          echo "üìä Final Workflow Report:"
          cat workflow-report.json | jq .
          
          # Summary
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "**Workflow ID**: ${{ github.run_id }} | **Run Number**: ${{ github.run_number }} | **Completed**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.build.result }}" = "success" ]; then
            echo "üéâ **Build pipeline completed successfully!**" >> $GITHUB_STEP_SUMMARY
          else
            echo "üí• **Build pipeline failed - review logs and troubleshooting guide above**" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload final workflow report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: workflow-report
          path: workflow-report.json
          retention-days: 90